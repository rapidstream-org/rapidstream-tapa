"""Defining the exporter to write Verilog designs from a graph IR node."""

__copyright__ = """
Copyright (c) 2025 RapidStream Design Automation, Inc. and contributors.
All rights reserved. The contributor(s) of this file has/have agreed to the
RapidStream Contributor License Agreement.
"""

from functools import singledispatch

from tapa.graphir.analyses.drc_check import check_missing_wire
from tapa.graphir.types import (
    AnyModuleDefinition,
    GroupedModuleDefinition,
    ModuleParameter,
    ModulePort,
    StubModuleDefinition,
    VerilogModuleDefinition,
)
from tapa.verilog.graphir_exporter.environment import env

TIME_SCALE = "`timescale 1 ns / 1 ps"


@singledispatch
def export_verilog_design(module: AnyModuleDefinition) -> str:
    """Return the verilog code of a module definition.

    Args:
        module (AnyModuleDefinition): The module to be exported.

    Returns:
        str: The Verilog code of the module definition.

    Examples:
        >>> module = GroupedModuleDefinition.model_validate_json(
        ...     '''{
        ...     "name": "empty_module",
        ...     "hierarchical_name": ["empty_orig_name"],
        ...     "parameters": [], "ports": [],
        ...     "module_type": "grouped_module",
        ...     "submodules": [], "wires": []}'''
        ... )
        >>> print(export_verilog_design(module))
        // ==================================================
        // RTL generated by RapidStream
        //
        // Copyright 2024 RapidStream Design Automation, Inc.
        // All Rights Reserved.
        // ==================================================
        `timescale 1 ns / 1 ps
        /**   empty_orig_name   **/
        module empty_module ();
        <BLANKLINE>
        <BLANKLINE>
        <BLANKLINE>
        endmodule  // empty_module

        >>> module = VerilogModuleDefinition(
        ...     name="empty_module",
        ...     hierarchical_name=("orig_name",),
        ...     parameters=[],
        ...     ports=[],
        ...     verilog="module empty_module (); endmodule;",
        ...     submodules_module_names=(),
        ... )
        >>> print(export_verilog_design(module))
        `timescale 1 ns / 1 ps
        module empty_module (); endmodule;
    """
    msg = f"An exporter for {type(module)} is not implemented.\n"
    raise NotImplementedError(msg)  # pragma: no cover


@export_verilog_design.register
def _(module: GroupedModuleDefinition) -> str:
    return export_verilog_grouped_module(module)


@export_verilog_design.register
def _(module: VerilogModuleDefinition) -> str:
    return export_verilog_verilog_module(module)


@export_verilog_design.register
def _(module: StubModuleDefinition) -> str:  # noqa: ARG001
    return "// This stub module is excluded from exporting"


def export_verilog_grouped_module(module: GroupedModuleDefinition) -> str:
    """Return the verilog code of a grouped module definition.

    Args:
        module (GroupedModuleDefinition): The module to be exported.

    Returns:
        str: The Verilog code of the grouped module definition.

    Examples:
        >>> module = GroupedModuleDefinition.model_validate_json(
        ...     '''{
        ...     "name": "nesting_module",
        ...     "hierarchical_name": ["orig_1"],
        ...     "parameters": [
        ...         {"name": "DEPTH", "hierarchical_name": ["orig_2", "D"],
        ...          "expr": [{"type": "lit", "repr": "16"}]}],
        ...     "ports": [
        ...         {"name": "test_in", "hierarchical_name": [],
        ...          "type": "input wire",
        ...          "range": {"left": [{"type": "lit", "repr": "31"}],
        ...                    "right": [{"type": "lit", "repr": "0"}]}},
        ...         {"name": "test_out", "hierarchical_name": ["test_out"],
        ...          "type": "output wire", "range": null}],
        ...     "module_type": "grouped_module",
        ...     "submodules": [{
        ...         "name": "submodule1",
        ...         "hierarchical_name": ["submodule1"],
        ...         "module": "nested_module",
        ...         "connections": [
        ...             {"name": "p1", "hierarchical_name": ["orig_6"],
        ...              "expr": [{"type": "id", "repr": "test_in"}]},
        ...             {"name": "p2", "hierarchical_name": ["p2"],
        ...              "expr": [{"type": "id", "repr": "test_wire"}]}],
        ...         "parameters": [], "floorplan_region": null, "area": null
        ...     }, {
        ...         "name": "submodule2",
        ...         "hierarchical_name": ["orig_8"],
        ...         "module": "nested_module",
        ...         "connections": [
        ...             {"name": "p1", "hierarchical_name": ["orig_9"],
        ...              "expr": [{"type": "id", "repr": "test_wire"}]},
        ...             {"name": "p2", "hierarchical_name": ["orig_10"],
        ...              "expr": [{"type": "id", "repr": "test_out"}]}],
        ...         "parameters": [{"name": "TEST", "hierarchical_name": ["TEST"],
        ...                         "expr": [{"type": "lit", "repr": "1"}]},
        ...                        {"name": "D", "hierarchical_name": ["orig_12"],
        ...                         "expr": [{"type": "id", "repr": "DEPTH"}]}],
        ...         "floorplan_region": null, "area": null
        ...     }],
        ...     "wires": [
        ...       {
        ...         "name": "test_wire",
        ...         "hierarchical_name": ["orig_13"],
        ...         "range": null
        ...       },
        ...       {"name": "unused_wire", "hierarchical_name": ["unused_wire"],
        ...        "range": {"left": [{"type": "lit", "repr": "31"}],
        ...                  "right": [{"type": "lit", "repr": "0"}]}}]}'''
        ... )
        >>> print(export_verilog_grouped_module(module))
        // ==================================================
        // RTL generated by RapidStream
        //
        // Copyright 2024 RapidStream Design Automation, Inc.
        // All Rights Reserved.
        // ==================================================
        `timescale 1 ns / 1 ps
        /**   orig_1   **/
        module nesting_module #(
            /**   orig_2/D   **/
            parameter DEPTH = 16
        ) (
            input wire  [31:0] test_in,
            output wire        test_out
        );
        <BLANKLINE>
        /**   orig_13   **/
        wire        test_wire;
        wire [31:0] unused_wire;
        <BLANKLINE>
        <BLANKLINE>
        <BLANKLINE>
        nested_module submodule1 (
            /**   orig_6   **/
            .p1 (test_in),
            .p2 (test_wire)
        );
        <BLANKLINE>
        <BLANKLINE>
        nested_module #(
            /**   orig_12   **/
            .D    (DEPTH),
            .TEST (1)
        ) submodule2 /**   orig_8   **/ (
            /**   orig_9   **/
            .p1 (test_wire),
            /**   orig_10   **/
            .p2 (test_out)
        );
        <BLANKLINE>
        endmodule  // nesting_module
    """
    pre_export_checks(module)

    template = env.get_template("grouped-module.v")
    return template.render(module=module)


def pre_export_checks(mod: GroupedModuleDefinition) -> None:
    """Run pre-export checks."""
    check_missing_wire(mod)


def export_verilog_verilog_module(module: VerilogModuleDefinition) -> str:
    """Return the verilog code of a verilog leaf module definition.

    Args:
        module (GroupedModuleDefinition): The module to be exported.

    Returns:
        str: The Verilog code of the verilog module definition.

    Examples:
        >>> print(
        ...     export_verilog_verilog_module(
        ...         VerilogModuleDefinition(
        ...             name="empty_module",
        ...             hierarchical_name=None,
        ...             parameters=[],
        ...             ports=[],
        ...             verilog="module empty_module; endmodule;",
        ...             submodules_module_names=(),
        ...         )
        ...     )
        ... )
        `timescale 1 ns / 1 ps
        module empty_module; endmodule;
    """
    # note that some simulation tools require a time scale
    # the original time scale info will be discarded by the importer
    # avoid adding duplicate time scale
    return (
        TIME_SCALE + "\n" + module.verilog
        if TIME_SCALE not in module.verilog
        else module.verilog
    )


def export_verilog_header(
    name: str,
    parameters: tuple[ModuleParameter, ...],
    ports: tuple[ModulePort, ...],
) -> str:
    """Return the verilog code of a tuple of port definitions.

    Args:
        name (str): The name of the module.
        parameters (tuple[ModuleParameter, ...]): The parameters of the module.
        ports (tuple[ModulePort, ...]): The ports of the module.

    Returns:
        str: The exported header ports tuple.

    Examples:
        >>> parameters = [
        ...     ModuleParameter.model_validate_json(
        ...         '''
        ...     {"name": "DEPTH", "hierarchical_name": ["D"],
        ...      "expr": [{"type": "lit", "repr": "16"}]}'''
        ...     )
        ... ]
        >>> ports = [
        ...     ModulePort.model_validate_json(
        ...         '''
        ...     {"name": "test1", "hierarchical_name": ["test1"], "type": "input wire",
        ...          "range": {"left": [{"type": "lit", "repr": "31"}],
        ...                    "right": [{"type": "lit", "repr": "0"}]}}'''
        ...     ),
        ...     ModulePort.model_validate_json(
        ...         '''
        ...     {"name": "test2", "hierarchical_name": ["T2"], "type": "output reg",
        ...          "range": {"left": [{"type": "lit", "repr": "1"}],
        ...                    "right": [{"type": "lit", "repr": "0"}]}}'''
        ...     ),
        ... ]
        >>> print(export_verilog_header("test", parameters, ports))
        module test #(
            /**   D   **/
            parameter DEPTH = 16
        ) (
            input wire [31:0] test1,
            /**   T2   **/
            output reg [ 1:0] test2
        );
    """
    template = env.get_template("module-header.v")
    return template.render(name=name, parameters=parameters, ports=ports)
